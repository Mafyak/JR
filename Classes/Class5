Документирование кода
Типы тегов - блочные (начинается с @ заканчивается с началом след тега) и строчные (вставлен в кавычки {})

@author - имя автора (classes and interfaces only, required)
@version - указывает версию пакета\класса\метода (classes and interfaces only, required)
@param <name> description (methods and constructors only)
@return - что метод возвращает (methods only)
@see <class name> - что можно ещё посмотреть по данной теме
@since - с какой версии код появился
@throws - что пробрасывается(в каких случаях и что)
@exception (@throws is a synonym added in Javadoc 1.2)
@deprecated - указывает на что заменён
@serial (or @serialField or @serialData)

Строчные
{@link} - ссылка на полезную инфу
{@value} - указывает дефолтное значение поля
{@docRoot} - ссылка на оригинальную документацию
{@code} - для непосредственно кода как примера

/**
 * @param  url  an absolute URL giving the base location of the image
 * @param  name the location of the image, relative to the url argument
 * @return      the image at the specified URL
 * @see         Image
*/

Компиляция JavaDoc: javadoc <options> <params> <files>
-sourcepath <path> - местоположение исходных файлов
-classpath <path> - местоположение используемых классов

По домашке - генерировать джавадок не надо

Параметризованные классы (Generics) 
? (Метасимвол) - использование объекта класса который параметризован другим типом -> sameAny(Mark<?> ob) примет на вход объекты
Mark<Integer> mi и Mark<Double> md и не будет ругаться.

<? super ***> - аналог <T extends ***>, только в противоположную сторону.
public <T> void fill (T obj) -> Значит что на вход метод может принимать ТОЛЬКО объекты 

Внутренние классы - внутренние нестат(inner), внутр статич(nested) и анонимные.
Inner классы имеют прямой доступ к полям и методам внешнего, даже к приватным.
Внешний класс имеет доступ к внутреннему классу только через объект внутреннего класса.
Внутренний класс не может содержать static полей, только final static.

Вложенные классы(nested).
Для доступа к членам внешнего класса внутренний должен создать объект этого класса
Но можем просто обращаться к статическим объектам и методам.
Статический метод вложенного класса вызывается при указании полного относительного пути к нему ( Outer1.Innter1.method();)
Подкласс вложенного класса не наследует возможности доступа к членам внешнего класса, которым наделён его суперкласс.
Класс вложенный в интерфейс, статический по умолчанию.

Анонимные классы
Нельзя переопределить.
